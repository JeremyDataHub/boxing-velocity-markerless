"""
Punch Velocity Analysis from Pose2Sim .trc Output

Computes 3D wrist velocity from joint position data exported by Pose2Sim.
Velocity components are derived numerically per axis, then combined into
a resultant velocity. Individual punches are detected via peak detection.

Input  : .trc file generated by Pose2Sim after 3D triangulation and filtering
Output : velocity plots per axis, resultant velocity plots, per-punch statistics

Author : Jérémy Birba
Project: REVEA — M2S Laboratory × French Boxing Federation
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.signal import find_peaks


# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

TRC_FILE = "transformed_test_smartphones_single_3300-6780_filt_butterworth.trc"

# Column indices for left and right wrist (x, y, z)
LWRIST_COLS = [70, 71, 72]
RWRIST_COLS = [52, 53, 54]

# Time ranges (seconds) for each subject
SUBJECT_1_RANGE = (60, 73)
SUBJECT_2_RANGE = (85, 106)

# Punch detection parameters
PUNCH_THRESHOLD = 4.0   # m/s
MIN_PEAK_DISTANCE = 10  # frames

# Number of punches per subject and wrist
PUNCH_COUNTS = {
    "Subject 1": {"Left": 13, "Right": 15},
    "Subject 2": {"Left": 2,  "Right": 14},
}


# ---------------------------------------------------------------------------
# I/O
# ---------------------------------------------------------------------------

def read_trc_file(file_path: str) -> pd.DataFrame:
    """Read a Pose2Sim .trc file and return its data as a DataFrame.

    Args:
        file_path: Path to the .trc file.

    Returns:
        DataFrame containing joint position data over time.
    """
    return pd.read_csv(file_path, skiprows=5, delimiter="\t")


# ---------------------------------------------------------------------------
# Signal processing
# ---------------------------------------------------------------------------

def calculate_velocity(position: np.ndarray, time: np.ndarray) -> np.ndarray:
    """Compute velocity by numerical differentiation of position over time.

    Args:
        position: 1D array of joint positions (m).
        time: 1D array of timestamps (s).

    Returns:
        1D array of velocity values (m/s).
    """
    return np.gradient(position, time)


def calculate_resultant(vx: np.ndarray, vy: np.ndarray, vz: np.ndarray) -> np.ndarray:
    """Compute the resultant (Euclidean norm) of 3D velocity components.

    Args:
        vx, vy, vz: Velocity components along each axis (m/s).

    Returns:
        1D array of resultant velocity magnitudes (m/s).
    """
    return np.sqrt(vx**2 + vy**2 + vz**2)


def extract_max_velocities(
    velocities: dict,
    resultant: np.ndarray,
    time: np.ndarray,
    time_range: tuple,
) -> tuple:
    """Extract peak velocity values within a time window.

    Args:
        velocities: Dict with keys 'tx', 'ty', 'tz' mapping to velocity arrays.
        resultant: Resultant velocity array (m/s).
        time: Timestamp array (s).
        time_range: (start, end) time window in seconds.

    Returns:
        Tuple of (per-axis max velocities dict, max resultant velocity).
    """
    mask = (time >= time_range[0]) & (time <= time_range[1])
    max_per_axis = {
        "X": np.max(np.abs(velocities["tx"][mask])),
        "Y": np.max(np.abs(velocities["ty"][mask])),
        "Z": np.max(np.abs(velocities["tz"][mask])),
    }
    max_resultant = np.max(resultant[mask])
    return max_per_axis, max_resultant


def find_punch_peaks(
    resultant: np.ndarray,
    time: np.ndarray,
    time_range: tuple,
    n_peaks: int,
    threshold: float = PUNCH_THRESHOLD,
    min_distance: int = MIN_PEAK_DISTANCE,
) -> np.ndarray:
    """Detect individual punches as velocity peaks above a threshold.

    Args:
        resultant: Resultant wrist velocity array (m/s).
        time: Timestamp array (s).
        time_range: (start, end) time window in seconds.
        n_peaks: Maximum number of peaks to return.
        threshold: Minimum velocity to qualify as a punch (m/s).
        min_distance: Minimum number of frames between two peaks.

    Returns:
        Array of peak velocity values sorted descending, or empty list if none found.
    """
    mask = (time >= time_range[0]) & (time <= time_range[1])
    segment = resultant[mask]

    peaks, properties = find_peaks(segment, height=threshold, distance=min_distance)

    if len(peaks) == 0:
        return []

    peak_values = properties["peak_heights"]
    sorted_indices = np.argsort(peak_values)[::-1]
    n_peaks = min(n_peaks, len(peak_values))
    return peak_values[sorted_indices[:n_peaks]]


# ---------------------------------------------------------------------------
# Plotting
# ---------------------------------------------------------------------------

def plot_velocity_axes(
    time: np.ndarray,
    velocities: dict,
    title: str,
    time_range: tuple = None,
) -> None:
    """Plot velocity components along X, Y, Z axes.

    Args:
        time: Timestamp array (s).
        velocities: Dict with keys 'tx', 'ty', 'tz'.
        title: Plot title.
        time_range: Optional (start, end) tuple to restrict the time axis.
    """
    if time_range:
        mask = (time >= time_range[0]) & (time <= time_range[1])
        plot_time = time[mask]
        plot_vel = {k: v[mask] for k, v in velocities.items()}
    else:
        plot_time = time
        plot_vel = velocities

    plt.plot(plot_time, plot_vel["tx"], label="X", color="red")
    plt.plot(plot_time, plot_vel["ty"], label="Y", color="green")
    plt.plot(plot_time, plot_vel["tz"], label="Z", color="blue")
    plt.title(title)
    plt.xlabel("Time (s)")
    plt.ylabel("Velocity (m/s)")
    plt.legend()
    plt.grid(True)
    plt.ylim(-8, 8)
    plt.yticks(np.arange(-8, 9, 1))


def plot_resultant_velocity(
    time: np.ndarray,
    resultant: np.ndarray,
    title: str,
    color: str,
    time_range: tuple = None,
) -> None:
    """Plot resultant wrist velocity over time.

    Args:
        time: Timestamp array (s).
        resultant: Resultant velocity array (m/s).
        title: Plot title.
        color: Line color.
        time_range: Optional (start, end) tuple to restrict the time axis.
    """
    if time_range:
        mask = (time >= time_range[0]) & (time <= time_range[1])
        plot_time = time[mask]
        plot_resultant = resultant[mask]
    else:
        plot_time = time
        plot_resultant = resultant

    plt.plot(plot_time, plot_resultant, color=color)
    plt.title(title)
    plt.xlabel("Time (s)")
    plt.ylabel("Velocity (m/s)")
    plt.grid(True)
    plt.ylim(0, 12)
    plt.yticks(np.arange(0, 13, 1))


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

if __name__ == "__main__":

    # Load data
    data = read_trc_file(TRC_FILE)
    time = data.iloc[:, 1].values

    # Compute velocity components for each wrist
    lwrist_vel = {
        "tx": calculate_velocity(data.iloc[:, LWRIST_COLS[0]].values, time),
        "ty": calculate_velocity(data.iloc[:, LWRIST_COLS[1]].values, time),
        "tz": calculate_velocity(data.iloc[:, LWRIST_COLS[2]].values, time),
    }
    rwrist_vel = {
        "tx": calculate_velocity(data.iloc[:, RWRIST_COLS[0]].values, time),
        "ty": calculate_velocity(data.iloc[:, RWRIST_COLS[1]].values, time),
        "tz": calculate_velocity(data.iloc[:, RWRIST_COLS[2]].values, time),
    }

    # Compute resultant velocities
    lwrist_resultant = calculate_resultant(lwrist_vel["tx"], lwrist_vel["ty"], lwrist_vel["tz"])
    rwrist_resultant = calculate_resultant(rwrist_vel["tx"], rwrist_vel["ty"], rwrist_vel["tz"])

    subjects = {
        "Subject 1": SUBJECT_1_RANGE,
        "Subject 2": SUBJECT_2_RANGE,
    }

    for subject, time_range in subjects.items():

        # Velocity per axis
        plt.figure(figsize=(12, 8))
        plt.subplot(2, 1, 1)
        plot_velocity_axes(time, lwrist_vel, f"Left wrist velocity — All axes — {subject}", time_range)
        plt.subplot(2, 1, 2)
        plot_velocity_axes(time, rwrist_vel, f"Right wrist velocity — All axes — {subject}", time_range)
        plt.tight_layout()

        # Resultant velocity
        plt.figure(figsize=(12, 8))
        plt.subplot(2, 1, 1)
        plot_resultant_velocity(time, lwrist_resultant, f"Left wrist velocity — Resultant — {subject}", "blue", time_range)
        plt.subplot(2, 1, 2)
        plot_resultant_velocity(time, rwrist_resultant, f"Right wrist velocity — Resultant — {subject}", "red", time_range)
        plt.tight_layout()

        # Statistics
        print(f"\n{'='*50}")
        print(f"{subject}")
        print(f"{'='*50}")

        mask = (time >= time_range[0]) & (time <= time_range[1])

        for wrist_label, velocities, resultant in [
            ("Left wrist",  lwrist_vel, lwrist_resultant),
            ("Right wrist", rwrist_vel, rwrist_resultant),
        ]:
            max_per_axis, max_resultant = extract_max_velocities(velocities, resultant, time, time_range)
            n = PUNCH_COUNTS[subject][wrist_label.split()[0]]
            peaks = find_punch_peaks(resultant, time, time_range, n_peaks=n)

            print(f"\n  {wrist_label}:")
            print(f"    Mean velocity    : {np.mean(resultant[mask]):.3f} m/s")
            print(f"    Max resultant    : {max_resultant:.2f} m/s")
            for axis, val in max_per_axis.items():
                print(f"    Max {axis}           : {val:.2f} m/s")
            if len(peaks) > 0:
                print(f"    Punch velocities : {[f'{v:.2f}' for v in peaks]}")
                print(f"    Mean punch speed : {np.mean(peaks):.2f} m/s")

    plt.show()
